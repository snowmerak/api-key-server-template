// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: store_query.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApiKey = `-- name: CreateApiKey :one
INSERT INTO apikeys (namespace, api_key, owner, service, permissions, payload, expired, expires_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) RETURNING api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

type CreateApiKeyParams struct {
	Namespace   string
	ApiKey      string
	Owner       string
	Service     string
	Permissions string
	Payload     []byte
	Expired     pgtype.Bool
	ExpiresAt   pgtype.Timestamptz
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (Apikey, error) {
	row := q.db.QueryRow(ctx, createApiKey,
		arg.Namespace,
		arg.ApiKey,
		arg.Owner,
		arg.Service,
		arg.Permissions,
		arg.Payload,
		arg.Expired,
		arg.ExpiresAt,
	)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Namespace,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM apikeys WHERE namespace = $1 AND api_key = $2
`

type DeleteApiKeyParams struct {
	Namespace string
	ApiKey    string
}

func (q *Queries) DeleteApiKey(ctx context.Context, arg DeleteApiKeyParams) error {
	_, err := q.db.Exec(ctx, deleteApiKey, arg.Namespace, arg.ApiKey)
	return err
}

const deleteApiKeysByOwner = `-- name: DeleteApiKeysByOwner :exec
DELETE FROM apikeys WHERE namespace = $1 AND owner = $2
`

type DeleteApiKeysByOwnerParams struct {
	Namespace string
	Owner     string
}

func (q *Queries) DeleteApiKeysByOwner(ctx context.Context, arg DeleteApiKeysByOwnerParams) error {
	_, err := q.db.Exec(ctx, deleteApiKeysByOwner, arg.Namespace, arg.Owner)
	return err
}

const deleteApiKeysByService = `-- name: DeleteApiKeysByService :exec
DELETE FROM apikeys WHERE namespace = $1 AND service = $2
`

type DeleteApiKeysByServiceParams struct {
	Namespace string
	Service   string
}

func (q *Queries) DeleteApiKeysByService(ctx context.Context, arg DeleteApiKeysByServiceParams) error {
	_, err := q.db.Exec(ctx, deleteApiKeysByService, arg.Namespace, arg.Service)
	return err
}

const deleteExpiredApiKeys = `-- name: DeleteExpiredApiKeys :exec
DELETE FROM apikeys WHERE namespace = $1 AND expired = TRUE
`

func (q *Queries) DeleteExpiredApiKeys(ctx context.Context, namespace string) error {
	_, err := q.db.Exec(ctx, deleteExpiredApiKeys, namespace)
	return err
}

const expireApiKey = `-- name: ExpireApiKey :one
UPDATE apikeys SET expired = TRUE AND updated_at = now() WHERE api_key = $1 RETURNING api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireApiKey(ctx context.Context, apiKey string) (Apikey, error) {
	row := q.db.QueryRow(ctx, expireApiKey, apiKey)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Namespace,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const expireApiKeysByOwner = `-- name: ExpireApiKeysByOwner :many
UPDATE apikeys SET expired = TRUE AND updated_at = now() WHERE owner = $1 RETURNING api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireApiKeysByOwner(ctx context.Context, owner string) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, expireApiKeysByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Namespace,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const expireApiKeysByService = `-- name: ExpireApiKeysByService :many
UPDATE apikeys SET expired = TRUE AND updated_at = now() WHERE service = $1 RETURNING api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireApiKeysByService(ctx context.Context, service string) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, expireApiKeysByService, service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Namespace,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const expireExpiredApiKeys = `-- name: ExpireExpiredApiKeys :many
UPDATE apikeys SET expired = TRUE AND updated_at = now() WHERE expires_at < $1 RETURNING api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireExpiredApiKeys(ctx context.Context, expiresAt pgtype.Timestamptz) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, expireExpiredApiKeys, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Namespace,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKey = `-- name: GetApiKey :one
SELECT api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at FROM apiKeys WHERE namespace = $1 AND api_key = $2 AND expired = FALSE
`

type GetApiKeyParams struct {
	Namespace string
	ApiKey    string
}

func (q *Queries) GetApiKey(ctx context.Context, arg GetApiKeyParams) (Apikey, error) {
	row := q.db.QueryRow(ctx, getApiKey, arg.Namespace, arg.ApiKey)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Namespace,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApiKeysByOwner = `-- name: GetApiKeysByOwner :many
SELECT api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at FROM apiKeys WHERE namespace = $1 AND owner = $2 AND expired = FALSE
`

type GetApiKeysByOwnerParams struct {
	Namespace string
	Owner     string
}

func (q *Queries) GetApiKeysByOwner(ctx context.Context, arg GetApiKeysByOwnerParams) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, getApiKeysByOwner, arg.Namespace, arg.Owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Namespace,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeysByService = `-- name: GetApiKeysByService :many
SELECT api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at FROM apiKeys WHERE namespace = $1 AND service = $2 AND expired = FALSE
`

type GetApiKeysByServiceParams struct {
	Namespace string
	Service   string
}

func (q *Queries) GetApiKeysByService(ctx context.Context, arg GetApiKeysByServiceParams) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, getApiKeysByService, arg.Namespace, arg.Service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Namespace,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE apikeys SET owner = $2, service = $3, permissions = $4, payload = $5, expired = $6, expires_at = $7, updated_at = now() WHERE api_key = $1 RETURNING api_key, namespace, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

type UpdateApiKeyParams struct {
	ApiKey      string
	Owner       string
	Service     string
	Permissions string
	Payload     []byte
	Expired     pgtype.Bool
	ExpiresAt   pgtype.Timestamptz
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (Apikey, error) {
	row := q.db.QueryRow(ctx, updateApiKey,
		arg.ApiKey,
		arg.Owner,
		arg.Service,
		arg.Permissions,
		arg.Payload,
		arg.Expired,
		arg.ExpiresAt,
	)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Namespace,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
