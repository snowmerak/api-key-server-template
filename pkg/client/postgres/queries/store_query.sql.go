// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: store_query.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createApiKey = `-- name: CreateApiKey :one
INSERT INTO apikeys (api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9) RETURNING api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

type CreateApiKeyParams struct {
	ApiKey      string
	Owner       string
	Service     string
	Permissions string
	Payload     []byte
	Expired     pgtype.Bool
	ExpiresAt   pgtype.Timestamptz
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) CreateApiKey(ctx context.Context, arg CreateApiKeyParams) (Apikey, error) {
	row := q.db.QueryRow(ctx, createApiKey,
		arg.ApiKey,
		arg.Owner,
		arg.Service,
		arg.Permissions,
		arg.Payload,
		arg.Expired,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteApiKey = `-- name: DeleteApiKey :exec
DELETE FROM apikeys WHERE api_key = $1
`

func (q *Queries) DeleteApiKey(ctx context.Context, apiKey string) error {
	_, err := q.db.Exec(ctx, deleteApiKey, apiKey)
	return err
}

const deleteApiKeysByOwner = `-- name: DeleteApiKeysByOwner :exec
DELETE FROM apikeys WHERE owner = $1
`

func (q *Queries) DeleteApiKeysByOwner(ctx context.Context, owner string) error {
	_, err := q.db.Exec(ctx, deleteApiKeysByOwner, owner)
	return err
}

const deleteApiKeysByService = `-- name: DeleteApiKeysByService :exec
DELETE FROM apikeys WHERE service = $1
`

func (q *Queries) DeleteApiKeysByService(ctx context.Context, service string) error {
	_, err := q.db.Exec(ctx, deleteApiKeysByService, service)
	return err
}

const deleteExpiredApiKeys = `-- name: DeleteExpiredApiKeys :exec
DELETE FROM apikeys WHERE expired = TRUE
`

func (q *Queries) DeleteExpiredApiKeys(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredApiKeys)
	return err
}

const expireApiKey = `-- name: ExpireApiKey :one
UPDATE apikeys SET expired = TRUE WHERE api_key = $1 RETURNING api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireApiKey(ctx context.Context, apiKey string) (Apikey, error) {
	row := q.db.QueryRow(ctx, expireApiKey, apiKey)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const expireApiKeysByOwner = `-- name: ExpireApiKeysByOwner :many
UPDATE apikeys SET expired = TRUE WHERE owner = $1 RETURNING api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireApiKeysByOwner(ctx context.Context, owner string) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, expireApiKeysByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const expireApiKeysByService = `-- name: ExpireApiKeysByService :many
UPDATE apikeys SET expired = TRUE WHERE service = $1 RETURNING api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireApiKeysByService(ctx context.Context, service string) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, expireApiKeysByService, service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const expireExpiredApiKeys = `-- name: ExpireExpiredApiKeys :many
UPDATE apikeys SET expired = TRUE WHERE expires_at < $1 RETURNING api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

func (q *Queries) ExpireExpiredApiKeys(ctx context.Context, expiresAt pgtype.Timestamptz) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, expireExpiredApiKeys, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKey = `-- name: GetApiKey :one
SELECT api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at FROM apiKeys WHERE api_key = $1 AND expired = FALSE
`

func (q *Queries) GetApiKey(ctx context.Context, apiKey string) (Apikey, error) {
	row := q.db.QueryRow(ctx, getApiKey, apiKey)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApiKeysByOwner = `-- name: GetApiKeysByOwner :many
SELECT api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at FROM apiKeys WHERE owner = $1 AND expired = FALSE
`

func (q *Queries) GetApiKeysByOwner(ctx context.Context, owner string) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, getApiKeysByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getApiKeysByService = `-- name: GetApiKeysByService :many
SELECT api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at FROM apiKeys WHERE service = $1 AND expired = FALSE
`

func (q *Queries) GetApiKeysByService(ctx context.Context, service string) ([]Apikey, error) {
	rows, err := q.db.Query(ctx, getApiKeysByService, service)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Apikey
	for rows.Next() {
		var i Apikey
		if err := rows.Scan(
			&i.ApiKey,
			&i.Owner,
			&i.Service,
			&i.Permissions,
			&i.Payload,
			&i.Expired,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateApiKey = `-- name: UpdateApiKey :one
UPDATE apikeys SET owner = $2, service = $3, permissions = $4, payload = $5, expired = $6, expires_at = $7, updated_at = $8 WHERE api_key = $1 RETURNING api_key, owner, service, permissions, payload, expired, expires_at, created_at, updated_at
`

type UpdateApiKeyParams struct {
	ApiKey      string
	Owner       string
	Service     string
	Permissions string
	Payload     []byte
	Expired     pgtype.Bool
	ExpiresAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
}

func (q *Queries) UpdateApiKey(ctx context.Context, arg UpdateApiKeyParams) (Apikey, error) {
	row := q.db.QueryRow(ctx, updateApiKey,
		arg.ApiKey,
		arg.Owner,
		arg.Service,
		arg.Permissions,
		arg.Payload,
		arg.Expired,
		arg.ExpiresAt,
		arg.UpdatedAt,
	)
	var i Apikey
	err := row.Scan(
		&i.ApiKey,
		&i.Owner,
		&i.Service,
		&i.Permissions,
		&i.Payload,
		&i.Expired,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
